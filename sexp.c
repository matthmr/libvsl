#include "debug.h"

#include "symtab.h"
#include "sexp.h"
#include "mm.h"

/** Base 'end' algorithm. See the `lisp_sexp_end' function */
static inline struct lisp_sexp* __lisp_sexp_end(struct lisp_sexp* expr_head) {
  if (!expr_head->root) {
    goto done;
  }

  do {
    expr_head = expr_head->root;
  } while (!IS_SEXP(expr_head->typ));

done:
  return expr_head;
}

/** Applies the 'transversal' algorithm, used to transverse the SEXP tree
    applying an action on each significant expression. This has the effect of
    'yielding' expressions.

    NOTE: we assume this is an expression tree generated by calling
    `lisp_sexp_node', `lisp_sexp_sym' and `lisp_sexp_end'. Note that that *will*
    make this function useless if trying to parse an arbitrary tree instead.

    -----

    The algorithm is broken up into three states:

    1. going leftwise
    2. going rightwise
    3. rebounding

    The default state is:

    (1.) will continue to issue itself unless the left child is a symbol or NIL,
    then (3.) is issued.

    (2.) will issue back (1.). If the right child is a symbol or NIL, then (3.)
    is issued.

    (3.) will either issue (2.) or itself again. (3.) is broken up into further
    states:
      (3a.): if rebounding from the left, do (2.).
      (3b.): if rebounding from the right, do (3.).

    If root was hit from (3b.) stop the algorithm.

    -----

    Here's a visualization (the examples below go from `a' to `b' to `c'):

    +--------+--------+-------+------------+------------+
    | 1.   a | 2. a   | 3. b  | 3a.   b    | 3b. [c]    |
    |     /  |     \  |    |  |      / \   |       \    |
    |    b   |      b |    a  |     a  [c] |        b   |
    |        |     /  |       |            |         \  |
    |        |   [c]  |       | 3 -> 2     | 3 -> 3   a |
    +--------+--------+-------+------------+------------+ */
static struct lisp_yield
lisp_sexp_yield(struct lisp_yield yield,
                const enum lisp_yield_ignore_t ignore) {
  register enum lisp_yield_t ret = yield.stat;

  struct lisp_sexp* _expr_head = NULL, * expr_head = yield.exp;
  struct lisp_yield      ret_t = {0};

  //// HANDLE PREVIOUS STATE

  switch (ret) {
  case __YIELD_LEFT_OBJ:
    goto rightwise;
  case __YIELD_RIGHT_OBJ:
    goto rebound;
  case __YIELD_END_EXPR:
    expr_head = expr_head->root;
    goto rebound;
  default:
    goto leftwise;
  }

rebound:
  if (!expr_head || !expr_head->root) {
    DB_MSG("[ sexp ] yield: done");

    defer_as(__YIELD_DONE);
  }

  _expr_head = expr_head;
  expr_head  = expr_head->root;

  // from the left
  if (expr_head->left._.exp == _expr_head) {
    DB_MSG("[ sexp ] yield: rebound: from-left");

    goto rightwise;
  }

  // from the right
  else {
    DB_MSG("[ sexp ] yield: rebound: from-right");

    if (IGNORE_REBOUND(ignore) && IS_LEXP(_expr_head->typ)) {
      goto rebound;
    }

    expr_head = _expr_head;
    defer_as(__YIELD_END_EXPR);
  }

rightwise:
  if (RIGHT_EXPR(*expr_head)) {
    expr_head = expr_head->right._.exp;

    DB_FMT("[ sexp ] yield: (rebound-left) right -> expr (%p)", expr_head);

    if (IGNORE_OBJ(ignore) ||
        (IGNORE_LEXP(ignore) && IS_LEXP(expr_head->typ))) {
      goto leftwise;
    }

    defer_as(__YIELD_RIGHT_EXPR);
  }

  else if (!RIGHT_NIL(*expr_head)) {
    DB_MSG("[ sexp ] yield: (rebound-left) right -> obj");

    if (IGNORE_OBJ(ignore)) {
      goto rebound;
    }

    defer_as(__YIELD_RIGHT_OBJ);
  }

  else {
    DB_MSG("[ sexp ] yield: (rebound-left) right -> nil");
    defer_as(__YIELD_END_EXPR);
  }

leftwise:
  if (LEFT_EXPR(*expr_head)) {
    expr_head = expr_head->left._.exp;

    DB_FMT("[ sexp ] yield: left -> expr (%p)", expr_head);

    // we assume this tree doesn't have any left LEXPs
    if (IGNORE_OBJ(ignore)) {
      goto leftwise;
    }

    defer_as(__YIELD_LEFT_EXPR);
  }

  else if (!LEFT_NIL(*expr_head)) {
    DB_MSG("[ sexp ] yield: left -> obj");

    if (IGNORE_OBJ(ignore)) {
      goto rightwise;
    }

    defer_as(__YIELD_LEFT_OBJ);
  }

  else {
    DB_MSG("[ sexp ] yield: left -> nil");
    defer_as(__YIELD_END_EXPR);
  }

  done_for_with(ret_t, (ret_t.exp  = expr_head,
                        ret_t.stat = ret));
}

static struct lisp_yield lisp_sexp_yield_for_clear(struct lisp_yield yield) {
  return lisp_sexp_yield(yield, __YIELD_IGNORE_OBJ);
}

/** Sets up an addition of an element, returning an LEXP as `lexp_head' */
static struct lisp_sexp*
lisp_sexp_on_lexp(struct lisp_sexp* expr_head, struct lisp_sexp* lexp_head) {
  lexp_head->typ  = __LISP_OBJ_LEXP;

  // root `lexp_head' in `expr_head'
  lexp_head->root = expr_head;

  // swap the old right of `expr_head' as the left of `lexp_head'
  lexp_head->left.typ = expr_head->right.typ;

  lexp_head->left = expr_head->right;

  expr_head->right.typ   = __LISP_OBJ_LEXP;
  expr_head->right._.exp = lexp_head;

  return lexp_head;
}

////////////////////////////////////////////////////////////////////////////////

struct lisp_yield lisp_sexp_yield_exp(struct lisp_yield yield) {
  return lisp_sexp_yield(yield, __YIELD_IGNORE_REBOUND|__YIELD_IGNORE_LEXP);
}

// DEBUG
#if 0
static struct lisp_trans lisp_sexp_yield_lit(struct lisp_trans trans) {
  return lisp_sexp_trans(trans, true, false);
}

struct lisp_sexp* lisp_sexp_copy(struct lisp_sexp* expr_head) {
  register int             ret = 0;

  struct lisp_sexp* _expr_head = NULL;
  struct lisp_sexp*      _head = NULL;
  struct lisp_trans       tret = {0};

  tret.exp  = expr_head;
  tret.stat = __TRANS_OK;

  _head      = mm_alloc(sizeof(*_head));
  _expr_head = _head;
  assert(_head, OR_ERR());

  _expr_head->t    = expr_head->t;
  _expr_head->root = NULL;

  do {
    tret = lisp_sexp_yield_lit(tret);

    if (tret.stat & __TRANS_LEFT_EXPR) {
      _head = mm_alloc(sizeof(*_head));
      assert(_head, OR_ERR());

      _head->t = tret.exp->t;

      _expr_head->left.exp = _head;
      _head->root          = _expr_head;

      _expr_head = _head;
    }
    else if (tret.stat & __TRANS_RIGHT_EXPR) {
      _head = mm_alloc(sizeof(*_head));
      assert(_head, OR_ERR());

      _head->t = tret.exp->t;

      _expr_head->right.exp = _head;
      _head->root           = _expr_head;

      _expr_head = _head;
    }

    //// SET

    else if (tret.stat & (__TRANS_REBOUND_LEFT | __TRANS_REBOUND_RIGHT)) {
      if (tret.stat & __TRANS_LEFT_SYM) {
        _expr_head->left.exp  = tret.exp->left.exp;
      }
      else if (tret.stat & __TRANS_RIGHT_SYM) {
        _expr_head->right.exp = tret.exp->right.exp;
      }

      _expr_head = _expr_head->root;
    }
  } while (!(tret.stat & __TRANS_DONE));

  done_for((_expr_head = ret? NULL: _expr_head));
}
#endif

void lisp_sexp_clear(struct lisp_sexp* expr_head) {
  if (!expr_head) {
    return;
  }

  struct lisp_yield     s_ret = {0};
  struct lisp_sexp* _expr_del = NULL;

  s_ret.exp  = expr_head;
  s_ret.stat = __YIELD_OK;

  // simple mark-and-sweep implementation
  do {
    s_ret     = lisp_sexp_yield_for_clear(s_ret);
    expr_head = s_ret.exp;

    if (s_ret.stat == __YIELD_END_EXPR) {
      mm_free(_expr_del);
      _expr_del = expr_head;
    }
  } while (s_ret.stat != __YIELD_DONE);

  // NOTE: this *never* frees more than once
  mm_free(_expr_del);
  mm_free(expr_head);
}

struct lisp_sexp*
lisp_sexp_obj(struct lisp_obj obj, struct lisp_sexp* expr_head) {
  register int ret = 0;

  if (IS_NIL(expr_head->left.typ)) {
    /**
         ? [expr_head] <- ret
        /
       . [new_obj]
     */
    expr_head->left = obj;
  }

  else if (IS_NIL(expr_head->right.typ)) {
    /**
         . [expr_head] <- ret
        / \
       ?   . [new_obj]
     */
obj_right:
    expr_head->right = obj;
  }

  else {
    /**
         ? [expr_head]         ?
        / \             ===>  / \
       ?   ? [old_obj]       ?   ,   [lexp_head] } new memory <- ret
                                / \
                    [old_obj]  ?   * [new_obj]
     */
    struct lisp_sexp* lexp_head = mm_alloc(sizeof(*expr_head));
    assert(lexp_head, OR_ERR());

    expr_head = lisp_sexp_on_lexp(expr_head, lexp_head);

    DB_FMT("  -> add: sym: lexp (%p)", expr_head);

    goto obj_right;
  }

  done_for((expr_head = ret? NULL: expr_head));
}

struct lisp_sexp* lisp_sexp_end(struct lisp_sexp* expr_head) {
  if (IS_LEXP(expr_head->typ)) {
    expr_head = __lisp_sexp_end(expr_head);
  }

  if (expr_head->root) {
    expr_head = expr_head->root;
  }

  DB_FMT("[ sexp ] end (%p)", expr_head);

  return expr_head;
}
